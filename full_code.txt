==================================================
FILE PATH: ./InitDrive.c
==================================================
#include "InitDrive.h"

void InitDrive(void){
    SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK; //already done in InitPWM.h	

    PORTB->PCR[rforward] |= PORT_PCR_MUX(1);
    PORTB->PCR[rreverse] |= PORT_PCR_MUX(1);

    PORTB->PCR[lforward] |= PORT_PCR_MUX(1);
    PORTB->PCR[lreverse] |= PORT_PCR_MUX(1);

    PTB->PDDR |= (rforward_mask | rreverse_mask | lforward_mask | lreverse_mask);
}


==================================================
FILE PATH: ./InitDrive.h
==================================================
#include "MKL05Z4.h"
#define rforward 10 //PTB10 
#define rreverse 11 //PTB11 
#define lforward 8 //PTB8
#define lreverse 13 //PTB13

#define rforward_mask (1<<10) 
#define rreverse_mask (1<<11) 
#define lforward_mask (1<<12) 
#define lreverse_mask (1<<13)

void InitDrive(void);




==================================================
FILE PATH: ./InitPWM.c
==================================================
#include "MKL05Z4.h"
#include "InitPWM.h"

void InitPWM(){
	SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK;		// Enabling port B clock
	SIM->SCGC5 |= SIM_SCGC5_PORTA_MASK;		// Enabling port A clock

	PORTB->PCR[rspd] |= PORT_PCR_MUX(2);
	PORTA->PCR[lspd] |= PORT_PCR_MUX(2);	// Enabling right and left speed control pins as PWM
	
	SIM->SCGC6 |= SIM_SCGC6_TPM1_MASK;		// Enabling TMP1 clock
	SIM->SOPT2 |= SIM_SOPT2_TPMSRC(1);		// clock source = TPMx MCGFLLCLK=41943040Hz
	
	TPM1->SC &= ~TPM_SC_CPWMS_MASK;		//	TPM1 counting forwards
	TPM1->SC |= TPM_SC_PS(6);	//	clock divider = 64; clock=655360Hz
	TPM1->MOD = 25;		//	 MODULO=25 - f_pwm=25kHz (we need 25kHz to eliminate irritating sounds the car may make)

	//right engine
	TPM1->CONTROLS[1].CnSC = TPM_CnSC_MSB_MASK|TPM_CnSC_ELSA_MASK;	//	TPM1 - Edge-aligned PWM Low-true pulses (set Output on match, clear Output on reload)
	TPM1->CONTROLS[1].CnV = 0x0000;					// fill factor = 0

	//left engine
	TPM1->CONTROLS[0].CnSC = TPM_CnSC_MSB_MASK|TPM_CnSC_ELSA_MASK;	//	TPM1 - Edge-aligned PWM Low-true pulses (set Output on match, clear Output on reload)
	TPM1->CONTROLS[0].CnV = 0x0000;					// fill factor = 0

	TPM1->SC |= TPM_SC_CMOD(1);						// Enable TPM1
}


==================================================
FILE PATH: ./InitPWM.h
==================================================
#include "MKL05Z4.h"
#define rspd 5 //PTB5 -> TPM1_CH1
#define lspd 12 //PTA12 -> TPM1_CH0

void InitPWM(void);



==================================================
FILE PATH: ./InitUART.c
==================================================
#include "InitUART.h"

void InitUART(void){
	SIM->SCGC4 |= SIM_SCGC4_UART0_MASK;							
	SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK;							
	SIM->SOPT2 |= SIM_SOPT2_UART0SRC(MCGFLLCLK);		
	PORTB->PCR[1] = PORT_PCR_MUX(2);								
	PORTB->PCR[2] = PORT_PCR_MUX(2);								
	
	UART0->C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK );		
	UART0->BDH = 0;
	UART0->BDL =272;		
	UART0->C4 = UART0_C4_OSR(15);	
	UART0->C5 |= UART0_C5_BOTHEDGE_MASK;	
	UART0->C2 |= UART0_C2_RIE_MASK;		
	UART0->C2 |= (UART0_C2_TE_MASK | UART0_C2_RE_MASK);		
	NVIC_EnableIRQ(UART0_IRQn);
	NVIC_ClearPendingIRQ(UART0_IRQn);
}


==================================================
FILE PATH: ./InitUART.h
==================================================
#include "MKL05Z4.h"
#define CLK_DIS 					0x00
#define MCGFLLCLK 		    		0x01
#define OSCERCLK					0x02
#define MCGIRCLK					0x03
#define TX_pin 1 //PORTB1 = TX
#define RX_pin 2 //PORTB2 = RX

void InitUART(void);




==================================================
FILE PATH: ./main.c
==================================================
#include "MKL05Z4.h"
#include "InitPWM.h"
#include "InitUART.h"
#include "steering.h"
#include <string.h>

volatile char rx_buffer[RX_BUFFER_SIZE];
volatile uint8_t buff_index = 0;
volatile uint8_t message_ready = 0;

int main(){
    InitPWM();
    InitUART();
    InitDrive();
    __enable_irq();

    while(1){
        if(message_ready == 1){
            steer();
            message_ready = 0; 
            // buff_index = 0;
            // UART0->C2 |= UART0_C2_RIE_MASK;
        }
    }
    return 0;
}

void UART0_IRQHandler(void) {

    uint32_t status = UART0->S1; //reading LPUART0 status flags

    if (status & (UART0_S1_OR_MASK | UART0_S1_NF_MASK | UART0_S1_FE_MASK | UART0_S1_PF_MASK)) {
        volatile uint8_t dummy = UART0->D; //removing trash from errors
        return; 
    }

    if (status & UART0_S1_RDRF_MASK) { //checking if a full byte arrived
        uint8_t received_byte = UART0->D; //storing received byte
            if (status & UART0_S1_RDRF_MASK) {
                uint8_t received_byte = UART0->D;
                if (received_byte == '\n') { 
                    message_ready = 1;

                    if (buff_index < RX_BUFFER_SIZE) {
                        rx_buffer[buff_index] = '\0'; 
                    }
                    
                    buff_index = 0;

                } else {
                    if (buff_index < (RX_BUFFER_SIZE - 1)) {
                        rx_buffer[buff_index] = received_byte;
                        buff_index++;
                    }
                }
        }
    }
}


==================================================
FILE PATH: ./steering.c
==================================================
#include "steering.h"
#include "InitDrive.h"
#include <stdlib.h>

void steer(){
    int16_t rspeed, lspeed;
    uint8_t forward = (rx_buffer[0] == 'F'); //checking if we go forward
    uint8_t right = (rx_buffer[3] == 'R'); //checking if we go right
    uint16_t speed = (rx_buffer[1]-'0')*10 + (rx_buffer[2]-'0'); //getting the speed value out of buffer
    uint16_t steer = (rx_buffer[4]-'0')*10 + (rx_buffer[5]-'0'); //getting the steering value out of buffer

    uint8_t rfwd = forward; //set directions
    uint8_t lfwd = forward;

    if (right) { //if we go right
        lspeed = speed + steer; //left enginge must go faster
        rspeed = speed - steer; //right engine must go slower
        if (rspeed < 0) rfwd = !rfwd; //check if turning and set appropriate direction
    } else {
        lspeed = speed - steer; //left enginge must go slower
        rspeed = speed + steer; //right engine must go faster
        if (lspeed < 0) lfwd = !lfwd; //check if turning and set appropriate direction
    }

    if (rfwd){ //if right engine needs to go forward
        PTB->PSOR |= rforward_mask; //set direction
        PTB->PCOR |= rreverse_mask;
    } else {
        PTB->PCOR |= rforward_mask; 
        PTB->PSOR |= rreverse_mask;
    }

    if (lfwd){ //if left engine needs to go forward
        PTB->PSOR |= lforward_mask; //set direction
        PTB->PCOR |= lreverse_mask;
    } else { 
        PTB->PCOR |= lforward_mask; 
        PTB->PSOR |= lreverse_mask;
    }
    
    //right engine PWM - PTB5 -> TPM1_CH1
    TPM1->CONTROLS[1].CnV = abs(rspeed*26/100);
    //left engine PWM - PTA12 -> TPM0_CH3
    TPM1->CONTROLS[0].CnV = abs(lspeed*26/100);
}


==================================================
FILE PATH: ./steering.h
==================================================
#include "MKL05Z4.h"

#define RX_BUFFER_SIZE 32
extern volatile char rx_buffer[RX_BUFFER_SIZE]; //buffer 
extern volatile uint8_t buff_index; 
extern volatile uint8_t message_ready;

void steer(void);




