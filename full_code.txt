==================================================
FILE PATH: ./InitDrive.c
==================================================
#include "InitDrive.h"

void InitDrive(void){
    //SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK; //already done in InitPWM.h	

    PORTB->PCR[rforward] |= PORT_PCR_MUX(1);
    PORTB->PCR[rreverse] |= PORT_PCR_MUX(1);

    PORTB->PCR[lforward] |= PORT_PCR_MUX(1);
    PORTB->PCR[lreverse] |= PORT_PCR_MUX(1);

    PTB->PDDR |= (rforward_mask | rreverse_mask | lforward_mask | lreverse_mask);
}


==================================================
FILE PATH: ./InitDrive.h
==================================================
#include "MKL05Z4.h"
#define rforward 10 //PTB10 
#define rreverse 11 //PTB11 
#define lforward 8 //PTB8
#define lreverse 13 //PTB13

#define rforward_mask (1<<10) 
#define rreverse_mask (1<<11) 
#define lforward_mask (1<<12) 
#define lreverse_mask (1<<13)

void InitDrive(void);




==================================================
FILE PATH: ./InitPWM.h
==================================================
#include "MKL05Z4.h"
#define rspd 5 //PTB5 -> TPM1_CH1
#define lspd 12 //PTA12 -> TPM1_CH0

void InitPWM(void);



==================================================
FILE PATH: ./InitUART.c
==================================================
#include "InitUART.h"

void InitUART(void){
	SIM->SCGC4 |= SIM_SCGC4_UART0_MASK;							
	SIM->SCGC5 |= SIM_SCGC5_PORTB_MASK;							
	SIM->SOPT2 |= SIM_SOPT2_UART0SRC(MCGFLLCLK);		
	PORTB->PCR[1] = PORT_PCR_MUX(2);								
	PORTB->PCR[2] = PORT_PCR_MUX(2);								
	
	UART0->C2 &= ~(UART0_C2_TE_MASK | UART0_C2_RE_MASK );		
	UART0->BDH = 0;
	UART0->BDL =272;		
	UART0->C4 = UART0_C4_OSR(15);	
	UART0->C5 |= UART0_C5_BOTHEDGE_MASK;	
	UART0->C2 |= UART0_C2_RIE_MASK;		
	UART0->C2 |= (UART0_C2_TE_MASK | UART0_C2_RE_MASK);		
	NVIC_EnableIRQ(UART0_IRQn);
	NVIC_ClearPendingIRQ(UART0_IRQn);
}


==================================================
FILE PATH: ./InitUART.h
==================================================
#include "MKL05Z4.h"
#define CLK_DIS 					0x00
#define MCGFLLCLK 		    		0x01
#define OSCERCLK					0x02
#define MCGIRCLK					0x03
#define TX_pin 1 //PORTB1 = TX
#define RX_pin 2 //PORTB2 = RX

void InitUART(void);




==================================================
FILE PATH: ./main.c
==================================================
#include "MKL05Z4.h"
#include "InitPWM.h"
#include "InitUART.h"
#include "steering.h"
#include <string.h>

volatile char rx_buffer[RX_BUFFER_SIZE];
volatile uint8_t buff_index = 0;
volatile uint8_t message_ready = 0;


int main(){
    InitPWM();
    InitUART();
    InitDrive();
    while(1){
        //nop
    }
    return 0;
}

void UART0_IRQHandler(void) {

    uint32_t status = UART0->S1; //reading LPUART0 status flags

    if (status & UART0_S1_RDRF_MASK) { //checking if a full byte arrived
        uint8_t received_byte = UART0->D; //storing received byte
        if (!message_ready && (buff_index < RX_BUFFER_SIZE)) { //if not full message
            rx_buffer[buff_index] = received_byte; //store to buffer at correct index
            buff_index++;
            if (buff_index == RX_BUFFER_SIZE) { //if full message
                message_ready = 1; 
                buff_index = 0; //reset index for new message
                UART0->C2 &= ~UART0_C2_RIE_MASK;	; //disable rx interrupts
            }
        }
    }

    if(message_ready){
        steer();
        UART0->C2 |= UART0_C2_RIE_MASK;	 //enable rx interrupts back again
    }



}


==================================================
FILE PATH: ./steering.c
==================================================
#include "steering.h"
#include "InitDrive.h"
#include <stdlib.h>

void steer(){
    int16_t rspeed, lspeed;
    uint8_t forward = (rx_buffer[0] == 'F'); //checking if we go forward
    uint8_t right = (rx_buffer[3] == 'R'); //checking if we go right
    uint16_t speed = (rx_buffer[1]-'0')*10 + (rx_buffer[2]-'0'); //getting the speed value out of buffer
    uint16_t steer = (rx_buffer[4]-'0')*10 + (rx_buffer[5]-'0'); //getting the steering value out of buffer

    uint8_t rfwd = forward; //set directions
    uint8_t lfwd = forward;

    if (right) { //if we go right
        lspeed = speed + steer; //left enginge must go faster
        rspeed = speed - steer; //right engine must go slower
        if (rspeed < 0) rfwd = !rfwd; //check if turning and set appropriate direction
    } else {
        lspeed = speed - steer; //left enginge must go slower
        rspeed = speed + steer; //right engine must go faster
        if (lspeed < 0) lfwd = !lfwd; //check if turning and set appropriate direction
    }

    if (rfwd){ //if right engine needs to go forward
        PTB->PSOR |= rforward_mask; //set direction
        PTB->PCOR |= rreverse_mask;
    } else {
        PTB->PCOR |= rforward_mask; 
        PTB->PSOR |= rreverse_mask;
    }

    if (lfwd){ //if left engine needs to go forward
        PTB->PSOR |= lforward_mask; //set direction
        PTB->PCOR |= lreverse_mask;
    } else { 
        PTB->PCOR |= lforward_mask; 
        PTB->PSOR |= lreverse_mask;
    }
    
    //right engine PWM - PTB5 -> TPM1_CH1
    TPM1->CONTROLS[1].CnV = abs(rspeed*26/100);
    //left engine PWM - PTA12 -> TPM0_CH3
    TPM1->CONTROLS[0].CnV = abs(lspeed*26/100);
}


==================================================
FILE PATH: ./steering.h
==================================================
#include "MKL05Z4.h"

#define RX_BUFFER_SIZE 10 
extern volatile char rx_buffer[RX_BUFFER_SIZE]; //buffer 
extern volatile uint8_t buff_index = 0; 
extern volatile uint8_t message_ready = 0;

void steer(void);




